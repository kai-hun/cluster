# **1장, 용어 정리**

## ROS

ROS(Robot Operating System)는 로봇을 개발하고 제어하도록 설계된 오픈 소스 미들웨어 프레임워크입니다. 이름에도 불구하고 ROS는 실제 운영 체제가 아니라 로봇 시스템 개발을 촉진하는 소프트웨어 라이브러리 및 도구 모음입니다. 하드웨어 추상화, 장치 드라이버, 프로세스 간 통신, 패키지 관리 등과 같은 서비스를 제공합니다.

1. **미들웨어:** ROS는 로봇 시스템의 다양한 구성 요소 간의 통신을 가능하게 하는 미들웨어를 제공합니다. 이 통신은 노드(소프트웨어 프로세스)가 특정 주제에 메시지를 게시하고 다른 노드가 해당 주제를 구독하여 메시지를 받는 게시-구독 메커니즘을 통해 수행될 수 있습니다.

2. **패키지 관리:** ROS는 코드 구성 및 배포를 위해 패키지 기반 시스템을 사용합니다. 패키지에는 라이브러리, 실행 파일, 스크립트, 구성 파일 등이 포함될 수 있습니다. 이 모듈식 구조를 통해 코드를 재사용하고 로봇 소프트웨어를 쉽게 배포할 수 있습니다.

3. **하드웨어 추상화:** ROS는 하드웨어를 추상화하여 개발자가 사용 중인 특정 로봇 하드웨어와 독립적인 코드를 작성할 수 있도록 합니다. 이러한 추상화는 개발 프로세스를 단순화하고 다양한 로봇 플랫폼 간에 코드를 더 쉽게 포팅할 수 있게 해줍니다.

4. **도구 및 시각화:** ROS에는 시각화, 디버깅 및 분석을 위한 도구 세트가 함께 제공됩니다. 이러한 도구에는 3D 시각화를 위한 RViz, 그래픽 사용자 인터페이스를 위한 RQT, 다양한 로깅 및 디버깅 도구가 포함됩니다.

5. **커뮤니티 및 생태계:** ROS의 강점 중 하나는 활발하고 협력적인 커뮤니티입니다. 개발자는 다양한 기존 패키지를 활용하고 ROS 생태계에 자신의 패키지를 기여할 수 있습니다.
ROS는 연구 프로젝트부터 상용 제품에 이르기까지 로봇 응용 프로그램을 개발하기 위해 학술 및 산업 환경에서 널리 사용됩니다. C++, Python 등을 포함한 다양한 프로그래밍 언어를 지원하므로 광범위한 개발자가 액세스할 수 있습니다.

## subscribe

ROS (로봇 운영 시스템)에서 "subscribe"는 노드(ROS 프레임워크 내의 소프트웨어 프로세스)가 특정 토픽에서 메시지를 받는 과정을 나타냅니다. ROS는 노드가 메시지를 특정 토픽에 발행하고 다른 노드가 해당 토픽을 구독하여 메시지를 수신할 수 있는 발행-구독 통신 모델을 사용합니다.

여기에서 간략한 용어 설명이 있습니다.

- **Publisher(발행자):**

    특정 토픽으로 메시지를 보내는 노드를 발행자라고 합니다.
    데이터를 생성하고 전송하며 일반적으로 센서 독자, 상태 업데이트 또는 기타 관련 정보를 나타냅니다.

- **Subscriber(구독자):**

    특정 토픽에서 메시지를 수신하는 노드를 구독자라고 합니다.
    들어오는 메시지를 처리하며 해당 기능에 필요한 데이터로 사용합니다.

- **Topic(토픽):**

    노드 간 통신을 위한 명명된 채널입니다. 노드는 메시지를 특정 토픽에 발행하고 다른 노드는 해당 토픽을 구독하여 메시지를 수신할 수 있습니다.
    토픽은 로봇 시스템의 서로 다른 부분 간에 정보를 교환하는 방법을 제공합니다.
    노드가 특정 토픽을 구독하면 해당 토픽에서 메시지를 받기에 흥미를 표현합니다. 그럼 ROS 미들웨어가 발행자 노드와 구독자 노드 간의 통신을 용이하게 합니다. 메시지는 비동기적으로 전송되어 로봇 시스템의 다른 구성 요소 간에 디커플링을 허용합니다.

예를 들어, 카메라 노드가 "camera/image" 토픽에 이미지를 발행하는 경우, 해당 이미지를 처리하고자 하는 다른 노드는 "camera/image" 토픽을 구독할 수 있습니다. 카메라 노드가 이미지를 캡처하면 해당 이미지를 "camera/image" 토픽에 발행하고, 구독 노드는 해당 이미지 데이터를 수신하고 처리할 수 있습니다.

요약하면, ROS에서의 구독은 노드가 특정 토픽에서 메시지를 수신하기에 흥미를 표현하는 과정으로, 로봇 시스템의 다른 부분 간에 통신 및 조정을 가능하게 합니다.

## sudo sh install.sh

`sudo sh install.sh`는 Linux 또는 Unix 기반 시스템에서 사용되는 명령어입니다. 이 명령어는 다음과 같은 역할을 합니다:

1. `sudo`: "superuser do"의 약자로, 슈퍼 유저 또는 관리자 권한으로 명령을 실행하도록 허용합니다. 일반 사용자가 시스템의 중요한 부분을 변경하거나 설치하기 위해 필요한 권한을 얻을 수 있습니다.

2. `sh`: Bourne 쉘 (Bourne Shell) 또는 호환 쉘 스크립트를 실행하는 명령어입니다. `install.sh` 파일은 일반적으로 쉘 스크립트 파일로, 시스템에 어떤 소프트웨어나 패키지를 설치하는 스크립트일 수 있습니다.

3. `install.sh`: 이는 실행하려는 쉘 스크립트 파일의 이름이며, 스크립트에는 설치 프로세스 및 다른 작업에 필요한 명령어가 포함될 것입니다.

따라서 `sudo sh install.sh` 명령어는 `install.sh`라는 스크립트를 슈퍼 유저 권한으로 실행하여 시스템에 어떤 소프트웨어나 패키지를 설치하려는 것으로 추정됩니다. 스크립트 내용과 설치할 내용에 따라 작동 방식이 다를 것이며, 실제 설치 프로세스 및 스크립트 내용은 `install.sh` 파일의 내용에 따라 다를 것입니다.

## alias(별칭)

#### cma(catkin_make -DCATKIN_WHITELIST_PACKAGES="")

'catkin_make' 명령어는 ROS 패키지를 빌드(컴파일)하는 데 사용됩니다. -DCATKIN_WHITELIST_PACKAGES="" 부분은 빌드 과정 중에 패키지를 위한 빌드 옵션을 제공하며, 여기서는 빈 화이트리스트를 설정하고 있습니다. 이는 모든 패키지가 빌드되며 빌드 프로세스에서 제외되지 않음을 의미합니다.

#### cca(catkin clean -y)

'catkin clean -y' 명령은 빌드 프로세스 중에 생성된 빌드 아티팩트 및 임시 파일을 정리(제거)하는 데 사용됩니다. -y 플래그는 청소 프로세스 중에 나타날 수 있는 프롬프트에 대해 "예"를 확인하는 데 자주 사용됩니다. 이는 수동 확인 없이 청소를 계속할 것임을 나타냅니다.

## blob

"Blob"은 "Binary Large Object"의 줄임말로, 컴퓨터 비전 및 이미지 처리에서 사용되는 용어입니다. 여기서 "Blob"은 주로 이미지에서 연결된 픽셀의 그룹을 나타냅니다. 이 그룹은 주로 물체나 특정 특징을 나타내는데 사용됩니다.

Blob은 일반적으로 다음과 같은 특징을 가지고 있습니다:

1. **이진 형태:** Blob은 픽셀의 이진 그룹으로 표현됩니다. 각 픽셀은 객체에 속하거나 속하지 않는 두 가지 값 중 하나를 가지며, 이는 주로 흑백 이미지에서 사용됩니다.

2. **연결성:** Blob은 서로 연결된 픽셀의 집합입니다. 연결된 픽셀은 이웃한 픽셀과 연결되어 있습니다.

3. **특징이나 물체 표현:** Blob은 주로 이미지에서 특정 특징이나 물체를 나타내는 데 사용됩니다. 예를 들어, 얼굴 인식에서는 각 얼굴이 하나의 Blob으로 표현될 수 있습니다.

Blob은 이미지 처리에서 다양한 응용 분야에서 사용됩니다. 몇 가지 예는 다음과 같습니다:

- **물체 감지:** 이미지에서 특정 물체를 찾거나 감지하는 데 사용됩니다.
  
- **모션 추적:** 동영상에서 물체의 움직임을 감지하고 추적하는 데 사용됩니다.
  
- **특징 추출:** 이미지에서 특정 특징을 식별하고 추출하는 데 사용됩니다.

이러한 응용 분야에서 Blob은 주로 특정 작업을 수행하기 위해 사용되는 중요한 개념입니다. 구체적인 구현 및 사용 사례에 따라 Blob의 정의와 의미가 다를 수 있습니다.

### _Blob tracking_

"Blob tracking"은 주로 컴퓨터 비전 및 이미지 처리 분야에서 사용되는 기술입니다. 이 기술은 이미지나 비디오에서 객체 또는 물체의 움직임을 감지하고 추적하는 것을 목적으로 합니다.

Blob tracking은 다음과 같은 단계로 구성될 수 있습니다:

1. **Blob Detection (Blob 감지):** 이미지나 비디오에서 움직이는 물체나 특징을 나타내는 blob을 감지합니다. 이 단계에서는 이미지에서 명암이나 색상 등을 기반으로 blob을 식별합니다.

2. **Blob Tracking (Blob 추적):** 감지된 blob을 프레임 간에 추적하여 물체의 움직임을 추정합니다. 이를 통해 물체의 위치, 속도, 방향 등을 추적할 수 있습니다.

Blob tracking은 여러 응용 분야에서 사용됩니다. 몇 가지 예는 다음과 같습니다:

- **로봇 비전 시스템:** 로봇이 환경에서 물체를 인식하고 추적하여 작업을 수행하는 데 사용됩니다.

- **자율 주행 차량:** 차량이 도로에서 다른 차량이나 장애물을 감지하고 추적하여 안전운전을 돕는 데 사용됩니다.

- **보안 시스템:** 감시 카메라에서 움직이는 물체를 감지하고 추적하여 보안 목적으로 사용됩니다.

- **게임 및 인터랙티브 시스템:** 인터랙티브 환경에서 사용자의 동작을 감지하고 추적하여 게임이나 가상 현실 시스템에서 상호 작용을 지원합니다.

Blob tracking은 환경에 따라 다양한 방법으로 구현될 수 있으며, 다양한 알고리즘 및 기술이 사용되어 객체를 효과적으로 추적하는 데 도움이 됩니다.

### _Blob PicknPlace_

"Blob PicknPlace"는 일반적으로 로봇 공학이나 자동화 분야에서 사용되는 용어 중 하나입니다.

**Pick and Place:**
   - "Pick and Place"는 로봇 시스템이 물체를 집어서(픽) 원하는 위치에 놓는(플레이스) 동작을 나타냅니다. 이것은 자동화된 생산 라인에서 특히 흔히 사용되는 작업 중 하나입니다.

따라서 "Blob PicknPlace"는 주로 로봇이 이미지 처리 기술을 사용하여 특정 형태나 색상의 blob(물체 또는 특정 부분)을 감지하고, 해당 blob을 집어서 다른 위치로 이동시키는 자동화된 프로세스를 의미할 수 있습니다. 이는 예를 들어 제조업에서 부품을 자동으로 선별하고 배치하는 로봇 시스템에 적용될 수 있습니다.

## Yolo

YOLO는 "You Only Look Once"의 약어로, 실시간 객체 감지를 수행하는 딥러닝 알고리즘을 나타냅니다. YOLO 알고리즘은 이미지나 동영상에서 여러 객체를 식별하고 해당 객체의 경계 상자(Bounding Box)와 클래스를 예측하는 데 사용됩니다.

YOLO의 주요 특징은 다음과 같습니다:

1. **실시간 객체 감지:** YOLO는 한 번의 forward pass(순방향 전파)로 이미지 전체에서 객체를 감지하고 식별할 수 있습니다. 이는 높은 처리 속도를 제공하며, 실시간 응용 분야에서 유용합니다.

2. **단일 네트워크:** YOLO는 하나의 신경망을 사용하여 객체 감지를 수행합니다. 다른 객체 감지 알고리즘과 달리 이미지를 여러 부분으로 나누지 않고 전체 이미지를 처리합니다.

3. **다양한 객체 분류:** YOLO는 여러 클래스의 객체를 동시에 감지할 수 있습니다. 예를 들어, 사람, 자동차, 개, 고양이 등 여러 객체 클래스를 식별할 수 있습니다.

4. **경계 상자의 회귀:** YOLO는 객체의 위치를 나타내는 경계 상자의 좌표를 예측합니다. 이는 객체 감지에 대한 정확한 위치 정보를 제공합니다.

YOLO는 다양한 버전이 존재하며, YOLOv3, YOLOv4 등은 각각 개선된 기능과 정확도를 제공합니다. YOLO는 주로 컴퓨터 비전 및 객체 감지 응용 분야에서 많이 사용되며, 자율 주행 차량, 보안 시스템, 로봇 공학 등 다양한 분야에서 응용됩니다.

# **2장. Jetpack & ROS install**

https://drive.google.com/file/d/1HU5F1cwiw2wzuNBdLL9R3Wvpg5AXLzw5/view?usp=sharing

id: jetson

passwd: jetson

## 1. Tool install on Jetson

### 1.1. Terminal(=SSH)에서 WiFi 연결하기

    # 실행해야할 명령
    $ sudo nmcli device wifi list
    $ sudo nmcli device wifi connect <ssid_name> password <password>
    $ ifconfig

    # 연결을 해제할 때
    $ sudo nmcli device disconnect wlan0
    
### 1.2 Cooling Fan

    $ cd Downloads
    $ git clone https://github.com/jetsonworld/jetson-fan-ctl.git
    $ cd jetson-fan-ctl
    
    $ sudo sh install.sh
    
### 1.3  jtop 사용

    $ jtop

## 2. ROS Melodic 설치

### 2.1 ROS Melodic 설치

    $ cd ~/Downloads/
    $ sudo apt update
    
    $ git clone https://github.com/zeta0707/installROS.git
    $ cd installROS
    $ ./install-ros.sh

### 2.2 .bashrc 수정

    $ gedit ~/.bashrc
    
    # 파일 제일 아래에 다음과 같은 내용 입력
    alias cma='catkin_make -DCATKIN_WHITELIST_PACKAGES=""'
    alias cop='catkin_make --only-pkg-with-deps'
    alias sds='source devel/setup.bash'
    alias coc='catkin clean'
    alias cca='catkin clean -y'

    source /opt/ros/melodic/setup.bash
    source ~/catkin_ws/devel/setup.bas

    # 에디터 종료 후 터미널 업데이트
    $ source ~/.bashrc

### 2.3 catkin workspace 설치

    jetson@jp4512G:~/catkin_ws$ cca
    
    jetson@jp4512G:~/catkin_ws$ cma

### 2.4 ROS 동작 확인(Option)

설치 후 제대로 되었는지 turtlesim으로 확인할 수 있습니다. 세 개의 창에 하나씩 아래 명령어를 실행해주세요.

    # 터미널 #1
    jetson@jp4512G:~/catkin_ws$ roscore
    # 터미널 #2
    jetson@jp4512G:~/catkin_ws$ rosrun turtlesim turtlesim_node
    # 터미널 #3
    jetson@jp4512G:~/catkin_ws$ rosrun turtlesim turtle_teleop_key

![Screenshot from 2023-11-01 18-40-55](https://github.com/kai-hun/cluster/assets/68891654/ae466a24-09a4-448e-9109-f0844c5deea3)

